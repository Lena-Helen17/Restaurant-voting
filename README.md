Совершенство достигнуто не тогда, когда нечего добавить, а тогда, когда нечего отнять
Антуан де Сент-Экзюпери
1: ТЗ (Тех.задание)
•	1.1: Читай ТЗ ОЧЕНЬ внимательно, НЕ надо ничего своего туда домысливать и творчески изменять
•	1.2: Учитывай, что пользователей может быть ОООЧЕНЬ много, а админов - МАЛО
•	1.3: Сначала сделай основные сценарии по ТЗ. Все остальное (если очень хочется, 3 раза подумай) - потом.
2. API
•	2.1: API продумывай с точки зрения не программиста и объектов, а с точки зрения того, кто им будет пользоваться (клиента, UI)
•	2.1: Тщательно считайте количество запросов в вашем API для отображения нужной информации
•	2.3: Из потребностей приложения (клиента) реализуй только очевидные сценарии. Необходимо и достаточно: ВСЕ НЕОБХОДИМОЕ для клиента и НИЧЕГО ЛИШНЕГО. Процесс творческий, приходит с опытом.
•	2.4: Делаем REST API в соответствии с концепцией REST (url в общем имеют вид{ресурс}/{id_ресурсa}[/{подресурс}/{id_подресурсa}][параметры]). Имена ресурсов во множественном числе! Самая распространенная и грубая ошибка - не придерживаться этих простых правил. 
o	15 тривиальных фактов о правильной работе с протоколом HTTP
o	10 Best Practices for Better RESTful API
o	REST resource hierarchy
o	Лучшие практики разработки REST API: правила 1-7,15-17
•	2.5: Разделение на роли я предпочитаю на уровне URL. Сразу и однозначно видно, какой API у админа, какое у пользователя (API админа начинается, например, с /admin/...).
•	2.6: На управление (CRUD) ресторанами и едой должны быть ОТДЕЛЬНЫЕ контроллеры. Не надо все, что может админ, сваливать в одну кучу!
•	2.7: Проверьте в Swagger, что в POST и PUT нет ничего лишнего, а в GET есть все необходимые данные. Например, при запросе голоса должен быть id ресторана, а при создании-редактировании ресторана не должно быть меню и еды.
•	2.8: Profile означает, что данные принадлежат профилю пользователя. Все остальное называйте по-другому.
3: Код:
•	3.1: Строго соблюдайте соглашения Java по именованию: пакеты ТОЛЬКО маленькими буквами, методы начинаются с маленькой буквы, классы с большой. Незнания Java Core - тестовое задание сразу в корзину.
•	3.2 В проекте (и тестовом задании на работу), в отличие от нашего учебного topjava, оставляйте только необходимый для работы по ТЗ приложения код, ничего лишнего 
o	3.2.1: НЕ надо делать разные профили базы и работы с ней
o	3.2.2: НЕ надо делать абстрактных контроллеров на всякий случай
o	3.2.3: НЕ надо делать сервисов, если там нет ничего, кроме делегирования
o	3.2.4: НЕ нужны локализация, UI, типы ошибок, Json View
•	3.3: Название пакетов, имен классов для model/to/web стандартные (например model/domain). НЕ надо придумывать своих собственных правил
•	3.4: Проверьте, не торчат ли из кода учебные уши TopJava, типа ProfileRestController.testUTF(), AbstractServiceTest.printResult() или закомментированные JdbcTemplate. Назначение выпускного совсем другое
•	3.5: Вместо return ResponseEntity.ok(object) в контроллерах пишите return object. Проще!
4: Модель
•	4.1: В БД обычно хранятся все введенные пользователем и админом данные (история). Они не удаляются и не переписываются заново. Есть базовые вещи, которые закладываются в архитектуру приложения, и есть неочевидные доработки к ТЗ, делать не надо.
•	4.2: Не делайте в модели объектов, которые не будут использоваться в коде (например, не надо двунаправленных связей, если достаточно однонаправленных)
•	4.3: еще раз про hashCode/equals в Entity: не делайте в модели сравнение по полям!
•	4.4: ORM работает с объектами. Иногда, для упрощения логики, fk_id как поля допустимы
5: Архитектура
•	5.1: Можно: 
o	или подключить DATA-REST (см.курс Spring Boot 2.x + HATEOAS). Контроллеры генерируются автоматически по репозиториям, требуется настройка ресурсов в кастомных контроллерах
o	или делать на основе миграции TopJava / кода TopJava-2
Нельзя смешивать эти подходы вместе! Я рекомендую 2-й вариант, без data-rest. Обязательно посмотрите в Swagger, какие контроллеры получились в результате.
•	5.2: Не размещайте бизнес-логику приложения и преобразования в TO в слое доступа к DB
•	5.3: Не смешивайте TO и Entity вместе. Они должны быть независимыми друг от друга. На TopJava мы смотрели разные варианты c использованием TO и без. Делаем максимально просто.
•	5.4: Use for money in java app
6: Доступ к БД
•	6.1: Используйте Spring Data JPA (без лишней делегации). Методы Repository можно вызывать напрямую из сервиса или из контроллера.
•	6.2: Если приложению в объекте требуется только его id, используйте reference (getById)
•	6.3: В DATA-JPA 2.x используются Optional. Попробуйте работать с ними, это безопасный способ работать с null-значениями (используйте orElseThrow)
•	6.4: Не делайте при обновлении записи ради экономии пары строчек кода так:
if(updateCondition)
   repository.delete(entity)
}
repository.save(entity)
Обновление записи базы должно быть через UPDATE.
7: База Данных
•	7.1: Берите без установки (H2 или HSQLDB). Одну и в памяти! Ваше приложение должно сразу запуститься, без всяких настроек и переменных окружения
•	7.2: Тщательно считайте количество обращений в базу на каждый запрос. Особенно при запросах от юзеров, которых очень много! Также на сложность запросов от них, чтобы не положить базу
•	7.3: Сделайте индексы к таблицам. Попробуйте обеспечить UNIQUE (один голос пользователя в день, один уникальный пункт меню в день). Следите за порядком полей в индексе, от этого зависит индексирование запросов.
•	7.4: При популировании добавь записи за сегодняшний день - now(), чтобы всегда были актуальные исходные данные
•	7.5: Поля базы case insensitive, не пишите camelStyle (для которых нужны кавычки)
•	7.6: Таблицы обычно именуются в единственном числе. Исключение - users, orders и другие зарезервированные слова
•	7.7: date/timestamp - зарезервированное слово, лучше избегать их при именовании полей
8: Security
•	8.1: Проверьте, станет ли код проще с @AuthenticationPrincipal (урок 11, Доступ к AuthorizedUser).
•	8.2: Я предпочитаю четкое разделение ролей на основе URL. Для админа URL содержит /admin
•	8.3: Еще раз - призываю не менять код TopJava
9: Кэширование
•	9.1: Кэширование желательно для частых и редко меняющихся запросов от пользователей. Тщательно продумайте, что надо кэшировать (самые частые запросы), а что нет (большие или редко запрашиваемые данные)
•	9.2: Проверьте соответствие ключей к кэшу (параметры кэшируемого метода) с конфигурацией (например в singleNonExpiryCache, heap=1 в кэше может содержаться только ОДНО значение).
10: Валидация
•	10.1: Одних аннотаций валидации недостаточно. Должны быть @Valid/@Validation
•	10.2: Проверяйте входные данные при create/update в контроллерах! В TopJava это ValidationUtil.checkNew()/assureIdConsistent()
11: Дополнительно
•	11.1: По возможности сделать JUnit-тесты. Можно не делать 100% покрытие, только основные сценарии
•	11.2: Уделяйте внимание обработке ошибок.
